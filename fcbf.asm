; ============================================
; МОДУЛЬ: sub_FCBF - Главный диспетчер игровых состояний
; Использует двухуровневую систему диспетчеризации:
; - $3EF выбирает таблицу
; - $3F0 выбирает функцию внутри таблицы
; Выполняет косвенный прыжок на выбранную функцию
; ============================================

.ifndef SUB_FCBF_INC
SUB_FCBF_INC = 1

.include "constants.inc"
.include "variables.inc"

.segment "CODE"

; ============================================
; PROC: sub_FCBF
; Вход: нет
; Выход: нет (не возвращается через RTS, а прыгает на функцию)
; Использует: A, X, Y, $93-$96 (zero page), $3F6, $42A
; ============================================
.proc sub_FCBF
    ; Сброс некоторого флага или счетчика
    lda #0
    sta $03F6              ; $3F6 = 0 (возможно, флаг или счетчик кадров)
    
    ; ========================================
    ; ВЫБОР ТАБЛИЦЫ НА ОСНОВЕ $3EF
    ; ========================================
    ; $3EF - индекс таблицы диспетчеризации (старший уровень)
    lda $03EF              ; Загружаем индекс таблицы
    asl a                  ; Умножаем на 2 (каждый указатель 2 байта)
    tax                    ; X = индекс × 2 (для 16-битной таблицы)
    
    ; Чтение указателя на таблицу функций из $FDD6
    ; $FDD6 - базовая таблица указателей на таблицы функций
    lda $FDD6, x           ; Младший байт указателя на таблицу функций
    sta $0093              ; Сохраняем в zero page $93 (низкоуровневый указатель)
    lda $FDD7, x           ; Старший байт указателя на таблицу функций
    sta $0094              ; Сохраняем в zero page $94
    
    ; ========================================
    ; ВЫБОР ФУНКЦИИ НА ОСНОВЕ $3F0
    ; ========================================
    ; $3F0 - индекс функции внутри выбранной таблицы (младший уровень)
    ; Обычно устанавливается другими частями кода:
    ; - sub_FC70 устанавливает $3F0 = 1 при нажатии Select
    ; - sub_FC43 инициализирует $3F0 = 0 при старте
    lda $03F0              ; Загружаем индекс функции
    asl a                  ; Умножаем на 2 (первые 2 байта каждой записи - адрес)
    tay                    ; Y = индекс × 2 (смещение в таблице)
    
    ; Косвенное чтение адреса функции из таблицы
    ; ($93) указывает на начало таблицы функций
    lda ($0093), y         ; Младший байт адреса функции
    sta $0095              ; Сохраняем в zero page $95
    iny                    ; Переходим к следующему байту
    lda ($0093), y         ; Старший байт адреса функции
    sta $0096              ; Сохраняем в zero page $96
    
    ; Чтение дополнительного параметра из таблицы
    ; Третий байт каждой записи сохраняется в $42A
    ; Вероятно, используется выбранной функцией как параметр
    iny                    ; Переходим к третьему байту записи
    lda ($0093), y         ; Загружаем дополнительное значение
    sta $042A              ; Сохраняем в $42A (возможно, параметр для функции)
    
    ; ========================================
    ; КОСВЕННЫЙ ПРЫЖОК НА ВЫБРАННУЮ ФУНКЦИЮ
    ; ========================================
    jmp ($0095)            ; Косвенный прыжок на адрес из $95/$96
    ; ВАЖНО: функция не возвращается через RTS!
    ; Выбранная функция должна сама в конце делать RTS
    ; чтобы вернуться в main_loop
.endproc

; ============================================
; СТРУКТУРА ДАННЫХ:
; ============================================
; Таблица в $FDD6 (основная таблица диспетчеризации):
;   Каждая запись: 2 байта указатель на таблицу функций
;   Всего записей: зависит от количества состояний игры
;
; Таблица функций (на которую указывает запись из $FDD6):
;   Каждая запись: 3 байта
;   - Байт 0-1: Адрес функции (little-endian)
;   - Байт 2:   Значение для $42A (параметр)
;
; Пример:
;   Если $3EF = 0, $3F0 = 1:
;   1. Берём указатель из $FDD6+0 → указывает на Table0
;   2. Берём запись из Table0+3 (индекс 1 × 3 байта)
;   3. Прыгаем на адрес из этой записи
;   4. $42A получает значение из 3-го байта записи
; ============================================